<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schelling's Dynamic Models of Segregation</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>Schelling's Dynamic Models of Segregation - Version 4</h1>
    </header>
    
    <section>
        <h2>Project Overview</h2>
        <p>This project simulates Schelling's Dynamic Models of Segregation, now updated to Version 4. The simulation includes:</p>
        <ul>
            <li>50 agents</li>
            <li>Improved visualizations (larger grid, better movement tracking)</li>
            <li>No explicit tipping point logic</li>
            <li>Updated algorithm for agent movement and satisfaction</li>
        </ul>
    </section>

    <section>
        <h2>Simulation Code</h2>
        <p>Below is the core Python code for the segregation model simulation. The code simulates the behavior of agents in a grid and tracks their movements based on neighborhood composition and personal preferences.</p>
        
        <pre>
<code>
 class Agent:
    def __init__(self, id, group, preference, current_location):
        self.id = id
        self.group = group  
        self.preference = preference  
        self.current_location = current_location  

    def calculate_similarity(self, neighbors):
        same_group_neighbors = sum(1 for neighbor in neighbors if neighbor.group == self.group)
        return same_group_neighbors / len(neighbors) if neighbors else 0

    def is_satisfied(self, neighbors):
        return self.calculate_similarity(neighbors) >= self.preference

class SegregationModel:
    def __init__(self, grid_size, num_agents, group_distribution, preference):
        self.grid = Grid(grid_size)
        self.agents = [Agent(id=i, group=random.choice(group_distribution), preference=random.choice(preference),
                             current_location=self.grid.find_vacant_location()) for i in range(num_agents)]

    def run_simulation(self, max_iterations):
        for iteration in range(max_iterations):
            for agent in self.agents:
                if not agent.is_satisfied(self.grid.get_neighbors(agent.current_location)):
                    new_location = self.grid.find_vacant_location()
                    if new_location:
                        agent.move_to(new_location)

</code>
        </pre>
        
        <p>View the full project on <a href="https://github.com/ChadL22/Schelling-s-Dynamic-Models-of-Segregation" target="_blank">GitHub</a>.</p>
    </section>

    <section>
        <h2>Initial and Final Grid Visualizations</h2>
        <p>Here are the initial and final grid conditions from one of the simulations:</p>
        <img src="initial_grid.png" alt="Initial Grid Conditions">
        <img src="final_grid.png" alt="Final Grid Conditions">
    </section>

    <footer>
        <p>&copy; 2024 Schelling Simulation Project</p>
    </footer>
</body>
</html>
